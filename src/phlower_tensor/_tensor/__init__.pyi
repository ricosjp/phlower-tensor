from __future__ import annotations

import abc
from collections.abc import Callable, Sequence
from typing import Any, overload

import numpy as np
import torch

from phlower_tensor._array import IPhlowerArray
from phlower_tensor._tensor._dimension import (
    PhlowerDimensionTensor,
    PhysicDimensionLikeObject,
    phlower_dimension_tensor,
    zero_dimension_tensor,
)
from phlower_tensor._tensor._tensor_shape import PhlowerShapePattern

@overload
def phlower_tensor(
    tensor: list | float | np.ndarray | torch.Tensor | PhlowerTensor,
    dimension: PhysicDimensionLikeObject | None = None,
    is_time_series: bool | None = False,
    is_voxel: bool | None = False,
    dtype: torch.dtype | None = None,
    device: torch.device | str | None = None,
) -> PhlowerTensor: ...
@overload
def phlower_tensor(
    tensor: list | float | np.ndarray | torch.Tensor | PhlowerTensor,
    dimension: PhysicDimensionLikeObject | None = None,
    pattern: PhlowerShapePattern | str = "n...",
    dtype: torch.dtype | None = None,
    device: torch.device | str | None = None,
) -> PhlowerTensor: ...

class PhlowerTensor(metaclass=abc.ABCMeta):
    @property
    def has_dimension(self) -> bool: ...
    @property
    def dimension(self) -> PhlowerDimensionTensor | None: ...
    @property
    def shape(self) -> torch.Size: ...
    @property
    def shape_pattern(self) -> PhlowerShapePattern: ...
    @property
    def is_sparse(self) -> bool: ...
    @property
    def is_time_series(self) -> bool: ...
    @property
    def is_voxel(self) -> bool: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def time_series_length(self) -> int: ...
    def __init__(
        self,
        tensor: torch.Tensor,
        dimension_tensor: PhlowerDimensionTensor | None = None,
        is_time_series: bool = False,
        is_voxel: bool = False,
    ): ...
    def values(self) -> torch.Tensor: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __le__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __gt__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __ge__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __abs__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __sub__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rsub__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __neg__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __add__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __radd__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __mul__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rmul__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __truediv__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rtruediv__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __pow__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __matmul__(
        self, other: PhlowerTensor | torch.Tensor
    ) -> PhlowerTensor: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, key: Any) -> PhlowerTensor: ...
    def to_tensor(self) -> torch.Tensor: ...
    def size(self) -> torch.Size: ...
    def rank(self) -> int: ...
    def n_vertices(self) -> int: ...
    def numel(self) -> int: ...
    def indices(self) -> torch.Tensor: ...
    def coalesce(self) -> PhlowerTensor: ...
    def to(
        self, device: str | torch.device, non_blocking: bool = False
    ) -> PhlowerTensor: ...
    def backward(self) -> None: ...
    def to_vertexwise(self) -> tuple[PhlowerTensor, str]: ...
    def to_numpy(self) -> np.ndarray: ...
    def is_global(self, n_batch: int) -> bool: ...
    def rearrange(
        self,
        pattern: str,
        **kwargs: int,
    ) -> PhlowerTensor: ...
    def reshape(
        self,
        shape: Sequence[int],
        is_time_series: bool = False,
        is_voxel: bool = False,
    ) -> PhlowerTensor: ...
    def as_pattern(self, pattern: str) -> PhlowerTensor: ...
    def clone(self) -> PhlowerTensor: ...
    def to_phlower_array(self) -> IPhlowerArray: ...
    def slice_time(
        self,
        indices: int | slice | list[int] | np.ndarray | torch.Tensor,
        keep_time_series: bool = True,
    ) -> PhlowerTensor: ...
    def __torch_function__(
        cls,
        func: Callable,
        types: list[type],
        args: tuple,
        kwargs: dict | None = None,
    ): ...

__all__ = [
    "PhlowerTensor",
    "phlower_tensor",
    "PhlowerDimensionTensor",
    "PhysicDimensionLikeObject",
    "phlower_dimension_tensor",
    "zero_dimension_tensor",
]
