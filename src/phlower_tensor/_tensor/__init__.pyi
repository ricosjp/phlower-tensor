from __future__ import annotations

import abc
from collections.abc import Callable, Sequence
from typing import Any, overload

import numpy as np
import torch

from phlower_tensor._array import IPhlowerArray
from phlower_tensor._base import PhysicalDimensions
from phlower_tensor._tensor._tensor_shape import PhlowerShapePattern

type PhysicDimensionLikeObject = (
    PhysicalDimensions
    | PhlowerDimensionTensor
    | torch.Tensor
    | dict[str, float]
    | list[float]
    | tuple[float]
)

@overload
def phlower_tensor(
    tensor: list | float | np.ndarray | torch.Tensor | PhlowerTensor,
    dimension: PhysicDimensionLikeObject | None = None,
    is_time_series: bool | None = False,
    is_voxel: bool | None = False,
    dtype: torch.dtype | None = None,
    device: torch.device | str | None = None,
) -> PhlowerTensor: ...
@overload
def phlower_tensor(
    tensor: list | float | np.ndarray | torch.Tensor | PhlowerTensor,
    dimension: PhysicDimensionLikeObject | None = None,
    pattern: PhlowerShapePattern | str = "n...",
    dtype: torch.dtype | None = None,
    device: torch.device | str | None = None,
) -> PhlowerTensor: ...
def phlower_dimension_tensor(
    values: dict[str, float] | PhysicalDimensions,
    dtype: torch.dtype = torch.float32,
    device: str | torch.device | None = None,
) -> PhlowerDimensionTensor: ...
def zero_dimension_tensor(
    device: str | torch.device | None,
) -> PhlowerDimensionTensor: ...

class PhlowerTensor(metaclass=abc.ABCMeta):
    @property
    def has_dimension(self) -> bool: ...
    @property
    def dimension(self) -> PhlowerDimensionTensor | None: ...
    @property
    def shape(self) -> torch.Size: ...
    @property
    def shape_pattern(self) -> PhlowerShapePattern: ...
    @property
    def is_sparse(self) -> bool: ...
    @property
    def is_time_series(self) -> bool: ...
    @property
    def is_voxel(self) -> bool: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def time_series_length(self) -> int: ...
    def __init__(
        self,
        tensor: torch.Tensor,
        dimension_tensor: PhlowerDimensionTensor | None = None,
        is_time_series: bool = False,
        is_voxel: bool = False,
    ): ...
    def values(self) -> torch.Tensor: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __le__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __gt__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __ge__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __abs__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __sub__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rsub__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __neg__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __add__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __radd__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __mul__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rmul__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __truediv__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __rtruediv__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __pow__(
        self, other: PhlowerTensor | torch.Tensor | float | int
    ) -> PhlowerTensor: ...
    def __matmul__(
        self, other: PhlowerTensor | torch.Tensor
    ) -> PhlowerTensor: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, key: Any) -> PhlowerTensor: ...
    def to_tensor(self) -> torch.Tensor: ...
    def size(self) -> torch.Size: ...
    def rank(self) -> int: ...
    def n_vertices(self) -> int: ...
    def numel(self) -> int: ...
    def indices(self) -> torch.Tensor: ...
    def coalesce(self) -> PhlowerTensor: ...
    def to(
        self, device: str | torch.device, non_blocking: bool = False
    ) -> PhlowerTensor: ...
    def backward(self) -> None: ...
    def to_vertexwise(self) -> tuple[PhlowerTensor, str]: ...
    def to_numpy(self) -> np.ndarray: ...
    def is_global(self, n_batch: int) -> bool: ...
    def rearrange(
        self,
        pattern: str,
        **kwargs: int,
    ) -> PhlowerTensor: ...
    def reshape(
        self,
        shape: Sequence[int],
        is_time_series: bool = False,
        is_voxel: bool = False,
    ) -> PhlowerTensor: ...
    def as_pattern(self, pattern: str) -> PhlowerTensor: ...
    def clone(self) -> PhlowerTensor: ...
    def to_phlower_array(self) -> IPhlowerArray: ...
    def slice_time(
        self,
        indices: int | slice | list[int] | np.ndarray | torch.Tensor,
        keep_time_series: bool = True,
    ) -> PhlowerTensor: ...
    def __torch_function__(
        cls,
        func: Callable,
        types: list[type],
        args: tuple,
        kwargs: dict | None = None,
    ): ...

class PhlowerDimensionTensor:
    """
    PhlowerDimensionTensor is a tensor that represents the physical dimensions

    Examples
    --------
    >>> dimension_tensor = PhlowerDimensionTensor(
    ...     values={"M": 1.0, "L": 1.0, "T": -2.0}
    ... )
    """

    @classmethod
    def from_list(
        cls,
        values: list[float] | tuple[float],
        dtype: torch.dtype = torch.float32,
        device: str | torch.device | None = None,
    ) -> PhlowerDimensionTensor:
        """
        Parse from list object

        Args:
            values (list[float] | tuple[float]): list or tuple
                if length of values is not equal to the number of registered
                dimension type, raise ValueError.

        Returns:
            PhlowerDimensionTensor: tensor object
        """
        ...

    def __sub__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __rsub__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __add__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __radd__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __mul__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __rmul__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __truediv__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __rtruediv__(self, __value: object) -> PhlowerDimensionTensor: ...
    def __eq__(self, other: object) -> bool: ...
    def __pow__(self, other: float | int) -> PhlowerDimensionTensor: ...
    def __repr__(self) -> str: ...
    def to_physics_dimension(self) -> PhysicalDimensions: ...
    def to_dict(self) -> dict[str, float]: ...
    def to(
        self,
        device: str | torch.device | None = None,
        non_blocking: bool = False,
        dtype: torch.dtype | None = None,
    ) -> PhlowerDimensionTensor: ...
    def detach(self) -> PhlowerDimensionTensor: ...
    def clone(self) -> PhlowerDimensionTensor: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def is_dimensionless(self) -> bool:
        """Return True if the tensor is dimensionless.

        Returns:
            bool: True if the tensor is dimensionless.
        """
        ...

    def numpy(self) -> np.ndarray:
        """Convert to numpy array

        Returns:
            np.ndarray: numpy array
        """
        ...

    @classmethod
    def __torch_function__(
        cls,
        func: Callable,
        types: list[type],
        args: tuple,
        kwargs: dict | None = None,
    ) -> PhlowerDimensionTensor: ...
